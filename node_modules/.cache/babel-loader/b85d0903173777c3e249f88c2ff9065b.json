{"ast":null,"code":"import $ from \"jquery\";\nimport { hexToRgbA } from '../../Utils'; // Create data series for the day's flot graph\n\nexport function createData(item, props, setModal) {\n  // Create initial data array of objects, including\n  // ranges accompanied by readings in each range\n  let data = [];\n\n  for (let i = 0; i < props.glucoseRanges.length; i++) {\n    let dataObj = {\n      range: props.glucoseRanges[i].slice(0, 2),\n      data: []\n    };\n    data.push(dataObj);\n  }\n\n  for (let i0 = 0; i0 < item.result.length; i0++) {\n    for (let i1 = 0; i1 < data.length; i1++) {\n      let gL = item.result[i0].glucose_level;\n\n      if (gL >= data[i1].range[0] && gL <= data[i1].range[1]) {\n        let hour = parseInt(item.result[i0].result_dt_tm.slice(11, 13));\n        let min = parseInt(item.result[i0].result_dt_tm.slice(14, 16));\n        let minDec = min / 60;\n        let time = hour + minDec;\n        data[i1].data.push([time, gL]);\n      }\n    }\n  } // Build array of arrays containing only each \n  // reading's time and glucose level\n\n\n  let TandGL = [];\n\n  for (let i = 0; i < data.length; i++) {\n    if (data[i].data.length != undefined) {\n      data[i].data.forEach(arr => {\n        TandGL.push(arr);\n      });\n    }\n  }\n\n  TandGL.sort((a, b) => {\n    return a[0] - b[0];\n  }); // Build array holding all ranges' thresholds\n\n  let thresholds = [];\n\n  for (let i = 0; i < props.glucoseRanges.length; i++) {\n    thresholds.push(props.glucoseRanges[i][0]);\n    thresholds.push(props.glucoseRanges[i][1]);\n  } // Begin creating data series to pass to flot graphs\n  // (the points to plot lines between)\n\n\n  let seriesArr = [];\n\n  for (let i0 = 0; i0 < TandGL.length - 1; i0++) {\n    // Functionality for assending glucose levels between readings\n    if (TandGL.length > 0 && TandGL[i0][1] < TandGL[i0 + 1][1]) {\n      // Except on the inital loop, add to the end of\n      // the series array the last point and the current one\n      // (to create next points to draw line between)\n      if (seriesArr.length > 0) {\n        seriesArr.push([seriesArr[seriesArr.length - 1][1], TandGL[i0]]);\n      } // Track number of threshold passes between adjecent readings\n      // (to add points at threshold passes, to allow for different\n      // colors of plot lines in between glucose readings)\n\n\n      let thresholdPasses = [];\n\n      for (let i1 = 0; i1 < thresholds.length; i1++) {\n        if (TandGL[i0][1] < thresholds[i1] && TandGL[i0 + 1][1] > thresholds[i1]) {\n          thresholdPasses.push(thresholds[i1]);\n        }\n      } // Add current time and glucose level \n      // to array that holds next series to pass\n      // to the array holding all series\n\n\n      let currentSeries = [TandGL[i0]]; // Get points and time gap between series\n      // (to be able to calculate times thresholds\n      // were passed, if glucose levels changed linearly)\n\n      let totalTimeGap = TandGL[i0 + 1][0] - TandGL[i0][0];\n      let totalPointsGap = TandGL[i0 + 1][1] - TandGL[i0][1]; // Loop through threshold passes to plot points\n      // for threshold passes between glucose readings\n      // (to allow line colors to match ranges)\n\n      for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n        let pointsDif = thresholdPasses[i2] - TandGL[i0][1];\n        let percOfTot = pointsDif / totalPointsGap;\n        let timeToAdd = percOfTot * totalTimeGap;\n        let time = timeToAdd + TandGL[i0][0]; // Add to the temp series to be pushed to all series,\n        // the time that each threshold was passed\n\n        currentSeries.push([time, thresholdPasses[i2]]); // If on last threshold pass, push next\n        // time and glucose reading to temp series\n\n        if (i2 == thresholdPasses.length - 1) {\n          currentSeries.push(TandGL[i0 + 1]);\n        } // If the temp series has 2 points,\n        // push to the series array and empty\n\n\n        if (currentSeries.length == 2) {\n          seriesArr.push(currentSeries);\n          currentSeries = [];\n        }\n      } // If no threshold passes, push to the series array\n      // the current and next times and glucose readings\n      // (because no points for color changes are needed)\n\n\n      if (thresholdPasses.length == 0) {\n        currentSeries.push(TandGL[i0 + 1]);\n        seriesArr.push(currentSeries);\n      } // Functionality for decreasing glucose levels between readings\n\n    } else if (TandGL.length > 0 && TandGL[i0][1] > TandGL[i0 + 1][1]) {\n      // Except on the inital loop, add to the end of the array\n      // holding all series - the last point and the current one\n      // (to create next points to draw line between)\n      if (seriesArr.length > 0) {\n        seriesArr.push([seriesArr[seriesArr.length - 1][1], TandGL[i0]]);\n      } // Track number of threshold passes between adjecent readings\n      // (to add points at threshold passes, to allow for different\n      // colors of plot lines in between glucose readings)\n\n\n      let thresholdPasses = [];\n\n      for (let i1 = 0; i1 < thresholds.length; i1++) {\n        if (TandGL[i0 + 1][1] < thresholds[i1] && TandGL[i0][1] > thresholds[i1]) {\n          thresholdPasses.push(thresholds[i1]);\n        }\n      }\n\n      thresholdPasses.reverse(); // Add current time and glucose level \n      // to array that holds next series to pass\n      // to the array holding all series\n\n      let currentSeries = [TandGL[i0]]; // Get points and time gap between series\n      // (to be able to calculate times thresholds\n      // were passed, if glucose levels changed linearly)\n\n      let totalTimeGap = TandGL[i0][0] - TandGL[i0 + 1][0];\n      let totalPointsGap = TandGL[i0 + 1][1] - TandGL[i0][1]; // Loop through threshold passes to plot points\n      // for threshold passes between glucose readings\n      // (to allow line colors to match ranges)\n\n      for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n        let pointsDif = TandGL[i0][1] - thresholdPasses[i2];\n        let percOfTot = pointsDif / totalPointsGap;\n        let timeToAdd = percOfTot * totalTimeGap;\n        let time = timeToAdd + TandGL[i0][0]; // Add to the temp series to be pushed to all series,\n        // the time that each threshold was passed\n\n        currentSeries.push([time, thresholdPasses[i2]]); // If on last threshold pass, push next\n        // time and glucose reading to temp series\n\n        if (i2 == thresholdPasses.length - 1) {\n          currentSeries.push(TandGL[i0 + 1]);\n        } // If the temp series has 2 points,\n        // push to the series array and empty\n\n\n        if (currentSeries.length == 2) {\n          seriesArr.push(currentSeries);\n          currentSeries = [];\n        }\n      } // If no threshold passes, push to the series array\n      // the current and next times and glucose readings\n      // (because no points for color changes are needed)\n\n\n      if (thresholdPasses.length == 0) {\n        currentSeries.push(TandGL[i0 + 1]);\n        seriesArr.push(currentSeries);\n      }\n    }\n  } // Add appropriate color for each data series,\n  // and push to new array hold all series\n\n\n  let dataPreSend = [];\n\n  for (let i0 = 0; i0 < seriesArr.length; i0++) {\n    let avg = (seriesArr[i0][0][1] + seriesArr[i0][1][1]) / 2;\n    let color;\n\n    for (let i1 = 0; i1 < props.glucoseRanges.length; i1++) {\n      if (avg > props.glucoseRanges[i1][0] && avg < props.glucoseRanges[i1][1]) {\n        color = props.glucoseRanges[i1][2];\n        break;\n      }\n    }\n\n    dataPreSend.push({\n      data: seriesArr[i0],\n      color: hexToRgbA(color, .5)\n    });\n  } // Add showable data points for the plotted points\n  // that are actual time and glucose readings\n  // (default functionality is data points do not show,\n  // because many points are only for line color changes;\n  // so actual glucose readings need seperate data series \n  // created for them, and then those series for actual \n  // points need to be added between data series arrays\n  // that are for plotting lines between glucose readings)\n\n\n  let dataToSend = []; // Loop through array of all series (with range colors)\n\n  for (let i0 = 0; i0 < dataPreSend.length; i0++) {\n    let firstT = dataPreSend[i0].data[0][0];\n    let firstGl = dataPreSend[i0].data[0][1];\n    let color = dataPreSend[i0].color;\n    let dataToPush = [];\n    let fAndOrL = \"0\"; // Loop through actual glucose readings, and\n    // see if current array in the array of all series\n    // contains 0, 1, or 2 actual glucose readings\n\n    for (let i1 = 0; i1 < TandGL.length; i1++) {\n      let TandGL0 = TandGL[i1][0];\n      let TandGL1 = TandGL[i1][1];\n      let fillColor = color;\n\n      if (color != undefined) {\n        fillColor = color.slice(0, color.indexOf(\")\") - 3) + \"1)\";\n      } // If the first item in the loop of the previous \n      // array of all series data's first glucose reading\n      // is equal to the current time and glucose reading\n      // in the loop of actual time and glucose readings,\n      // push the data point to the next all series array,\n      // and track that the first item in the loop of the \n      // prev. array of all series data is an actual reading\n\n\n      if (firstT == TandGL0 && firstGl == TandGL1) {\n        dataToPush.push({\n          data: [[firstT, firstGl]],\n          color: color,\n          points: {\n            show: true,\n            fill: true,\n            radius: 7,\n            fillColor: fillColor\n          }\n        });\n        fAndOrL = \"1\";\n      } // If the second item in the loop of the previous \n      // array of all series data's first glucose reading\n      // is equal to the current time and glucose reading\n      // in the loop of actual time and glucose readings,\n      // push the data point to the next all series array,\n      // and update tracking of which data points of current\n      // item of prev. array of all series data is/are\n      // actual glucose readings\n\n\n      let secondT = dataPreSend[i0].data[1][0];\n      let secondGl = dataPreSend[i0].data[1][1];\n\n      if (secondT == TandGL0 && secondGl == TandGL1) {\n        dataToPush.push({\n          data: [[secondT, secondGl]],\n          color: color,\n          points: {\n            show: true,\n            fill: true,\n            radius: 7,\n            fillColor: fillColor\n          }\n        });\n\n        if (fAndOrL == \"0\") {\n          fAndOrL = \"2\";\n        } else {\n          fAndOrL = \"12\";\n        }\n      }\n    } // If neither time and glucose level are\n    // actual glucose readings, push the pair \n    // to the new array of all series data\n\n\n    if (fAndOrL == \"0\") {\n      dataToSend.push(dataPreSend[i0]);\n    } // If just the first time and glucose level\n    // from the current item from the\n    // previouse array of all series data\n    // is an actual glucose reading, push the\n    // actual glucose reading data point,\n    // the then the current item from the\n    // previous array of all series data\n    else if (fAndOrL == \"1\") {\n        dataToSend.push(dataToPush[0]);\n        dataToSend.push(dataPreSend[i0]);\n      } // If just the second time and glucose level\n      // from the current item from the previous array \n      // of all series data is an actual glucose reading, \n      // push the current item from the previous array \n      // of all series data, then the current item \n      // from the previous array of all series data\n      else if (fAndOrL == \"2\") {\n          dataToSend.push(dataPreSend[i0]);\n          dataToSend.push(dataToPush[0]);\n        } // If both time and glucose levels\n        // from the current item from the\n        // previous array of all series data\n        // are actual glucose readings, push the\n        // actual glucose reading data points,\n        // and between them, the current item from \n        // the previous array of all series data\n        else {\n            dataToSend.push(dataToPush[0]);\n            dataToSend.push(dataPreSend[i0]);\n            dataToSend.push(dataToPush[1]);\n          }\n  } // This adjusts times for data series, to\n  // eliminate gaps in time between adj. series, \n  // to avoid gaps in lines on the graph\n\n\n  for (let i0 = 0; i0 < dataToSend.length - 1; i0++) {\n    let d0 = dataToSend[i0].data;\n    let d1 = dataToSend[i0 + 1].data;\n\n    if (d0.length == 1 && d1.length == 1) {\n      dataToSend.splice(i0, 1);\n    } else {\n      if (d0.length > 1 && d0[1][0] + .01 < d1[0][0]) {\n        for (let i1 = 0; i1 < TandGL.length; i1++) {\n          if (d0[1][0] === TandGL[i1][0] && d0[1][1] === TandGL[i1][1]) {\n            d1[0][0] = d0[1][0];\n          } else if (d1[0][0] === TandGL[i1][0] && d1[0][1] === TandGL[i1][1]) {\n            d0[1][0] = d1[0][0];\n          } else {\n            let num = (d1[0][0] - d0[1][0]) / 2;\n            d0[1][0] = d0[1][0] + num;\n            d1[0][0] = d1[0][0] - num;\n          }\n        }\n      }\n    }\n  } // Add the plotclick event listener to the graph\n  // that updates the state variable \"modal\", to open\n  // the modal with the appropriate point's data\n\n\n  let item0 = item;\n  $(`#${item0.date.replaceAll('/', '')}`).off('plotclick').on('plotclick', function (event, pos, item) {\n    event.stopPropagation();\n\n    if (item != null && item.datapoint) {\n      for (let i = 0; i < item0.result.length; i++) {\n        let result = item0.result[i];\n        let gL = result.glucose_level;\n        let hour = parseInt(result.result_dt_tm.slice(11, 13));\n        let min = parseInt(result.result_dt_tm.slice(14, 16));\n        let minDec = min / 60;\n        let time = hour + minDec;\n\n        if (item.datapoint[0] == time && item.datapoint[1] == gL) {\n          setModal({\n            open: true,\n            data: {\n              glucoseLevelNum: gL,\n              glucoseLevel: gL + result.glucose_level_unit,\n              resultDate: result.result_dt_tm,\n              source: result.source,\n              resultId: result.result_id\n            }\n          });\n          break;\n        }\n      }\n    }\n  });\n  return dataToSend;\n}","map":{"version":3,"sources":["/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/GraphUtils.js"],"names":["$","hexToRgbA","createData","item","props","setModal","data","i","glucoseRanges","length","dataObj","range","slice","push","i0","result","i1","gL","glucose_level","hour","parseInt","result_dt_tm","min","minDec","time","TandGL","undefined","forEach","arr","sort","a","b","thresholds","seriesArr","thresholdPasses","currentSeries","totalTimeGap","totalPointsGap","i2","pointsDif","percOfTot","timeToAdd","reverse","dataPreSend","avg","color","dataToSend","firstT","firstGl","dataToPush","fAndOrL","TandGL0","TandGL1","fillColor","indexOf","points","show","fill","radius","secondT","secondGl","d0","d1","splice","num","item0","date","replaceAll","off","on","event","pos","stopPropagation","datapoint","open","glucoseLevelNum","glucoseLevel","glucose_level_unit","resultDate","source","resultId","result_id"],"mappings":"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","sourcesContent":["import $ from \"jquery\";\nimport { hexToRgbA } from '../../Utils';\n\n// Create data series for the day's flot graph\nexport function createData(item, props, setModal) {\n    \n    // Create initial data array of objects, including\n    // ranges accompanied by readings in each range\n    let data = []\n    for (let i = 0; i < props.glucoseRanges.length; i++) {\n        let dataObj = {\n            range: props.glucoseRanges[i].slice(0,2),\n            data: []\n        }\n        data.push(dataObj)\n    }\n\n    for (let i0 = 0; i0 < item.result.length; i0++) {\n        for (let i1 = 0; i1 < data.length; i1++) {\n            let gL = item.result[i0].glucose_level\n            if (gL >= data[i1].range[0] && gL <= data[i1].range[1]) {\n                let hour = parseInt(item.result[i0].result_dt_tm.slice(11,13))\n                let min = parseInt(item.result[i0].result_dt_tm.slice(14,16))\n                let minDec = min/60\n                let time = hour + minDec\n                data[i1].data.push([time, gL])\n            }\n        }\n    }\n\n    // Build array of arrays containing only each \n    // reading's time and glucose level\n    let TandGL = []\n    for (let i = 0; i < data.length; i++) {\n        if (data[i].data.length != undefined) {\n            data[i].data.forEach((arr) => {\n                TandGL.push(arr)\n            })\n        }\n    }\n\n    TandGL.sort((a, b) => {\n        return a[0] - b[0]\n    })\n\n    // Build array holding all ranges' thresholds\n    let thresholds = []\n    for (let i = 0; i < props.glucoseRanges.length; i++) {\n        thresholds.push(props.glucoseRanges[i][0])\n        thresholds.push(props.glucoseRanges[i][1])\n    }\n\n    // Begin creating data series to pass to flot graphs\n    // (the points to plot lines between)\n    let seriesArr = []\n    for (let i0 = 0; i0 < TandGL.length - 1; i0++) {\n        // Functionality for assending glucose levels between readings\n        if (TandGL.length > 0 && TandGL[i0][1] < TandGL[i0+1][1]) {\n            // Except on the inital loop, add to the end of\n            // the series array the last point and the current one\n            // (to create next points to draw line between)\n            if (seriesArr.length > 0) {\n                seriesArr.push([\n                    seriesArr[seriesArr.length-1][1],\n                    TandGL[i0]\n                ])\n            }\n            // Track number of threshold passes between adjecent readings\n            // (to add points at threshold passes, to allow for different\n            // colors of plot lines in between glucose readings)\n            let thresholdPasses = []\n            for (let i1 = 0; i1 < thresholds.length; i1++) {\n                if (TandGL[i0][1] < thresholds[i1] && \n                    TandGL[i0+1][1] > thresholds[i1]) {\n                    thresholdPasses.push(thresholds[i1])\n                }\n            }\n            // Add current time and glucose level \n            // to array that holds next series to pass\n            // to the array holding all series\n            let currentSeries = [TandGL[i0]]\n            // Get points and time gap between series\n            // (to be able to calculate times thresholds\n            // were passed, if glucose levels changed linearly)\n            let totalTimeGap = TandGL[i0+1][0] - TandGL[i0][0]\n            let totalPointsGap = TandGL[i0+1][1] - TandGL[i0][1]\n            // Loop through threshold passes to plot points\n            // for threshold passes between glucose readings\n            // (to allow line colors to match ranges)\n            for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n                let pointsDif = thresholdPasses[i2] - TandGL[i0][1]\n                let percOfTot = pointsDif/totalPointsGap\n                let timeToAdd = percOfTot * totalTimeGap \n                let time = timeToAdd + TandGL[i0][0]\n                // Add to the temp series to be pushed to all series,\n                // the time that each threshold was passed\n                currentSeries.push([time, thresholdPasses[i2]])\n                // If on last threshold pass, push next\n                // time and glucose reading to temp series\n                if (i2 == thresholdPasses.length - 1) {\n                    currentSeries.push(TandGL[i0+1])\n                }\n                // If the temp series has 2 points,\n                // push to the series array and empty\n                if (currentSeries.length == 2) {\n                    seriesArr.push(currentSeries)\n                    currentSeries = []\n                }\n            }\n            // If no threshold passes, push to the series array\n            // the current and next times and glucose readings\n            // (because no points for color changes are needed)\n            if (thresholdPasses.length == 0) {\n                currentSeries.push(TandGL[i0+1])\n                seriesArr.push(currentSeries)\n            }\n        // Functionality for decreasing glucose levels between readings\n        } else if (TandGL.length > 0 && TandGL[i0][1] > TandGL[i0+1][1]) {\n            // Except on the inital loop, add to the end of the array\n            // holding all series - the last point and the current one\n            // (to create next points to draw line between)\n            if (seriesArr.length > 0) {\n                seriesArr.push([\n                    seriesArr[seriesArr.length-1][1],\n                    TandGL[i0]\n                ])\n            }\n            // Track number of threshold passes between adjecent readings\n            // (to add points at threshold passes, to allow for different\n            // colors of plot lines in between glucose readings)\n            let thresholdPasses = []\n            for (let i1 = 0; i1 < thresholds.length; i1++) {\n                if (TandGL[i0+1][1] < thresholds[i1] && \n                    TandGL[i0][1] > thresholds[i1]) {\n                    thresholdPasses.push(thresholds[i1])\n                }\n            }\n            thresholdPasses.reverse()\n            // Add current time and glucose level \n            // to array that holds next series to pass\n            // to the array holding all series\n            let currentSeries = [TandGL[i0]]\n            // Get points and time gap between series\n            // (to be able to calculate times thresholds\n            // were passed, if glucose levels changed linearly)\n            let totalTimeGap = TandGL[i0][0] - TandGL[i0+1][0]\n            let totalPointsGap = TandGL[i0+1][1] - TandGL[i0][1]\n            // Loop through threshold passes to plot points\n            // for threshold passes between glucose readings\n            // (to allow line colors to match ranges)\n            for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n                let pointsDif = TandGL[i0][1] - thresholdPasses[i2]\n                let percOfTot = pointsDif/totalPointsGap\n                let timeToAdd = percOfTot * totalTimeGap \n                let time = timeToAdd + TandGL[i0][0]\n                // Add to the temp series to be pushed to all series,\n                // the time that each threshold was passed\n                currentSeries.push([time, thresholdPasses[i2]])\n                // If on last threshold pass, push next\n                // time and glucose reading to temp series\n                if (i2 == thresholdPasses.length - 1 ) {\n                    currentSeries.push(TandGL[i0+1])\n                }\n                // If the temp series has 2 points,\n                // push to the series array and empty\n                if (currentSeries.length == 2) {\n                    seriesArr.push(currentSeries)\n                    currentSeries = []\n                }\n            }\n            // If no threshold passes, push to the series array\n            // the current and next times and glucose readings\n            // (because no points for color changes are needed)\n            if (thresholdPasses.length == 0) {\n                currentSeries.push(TandGL[i0+1])\n                seriesArr.push(currentSeries)\n            }\n        }\n    }\n\n    // Add appropriate color for each data series,\n    // and push to new array hold all series\n    let dataPreSend = []\n    for (let i0 = 0; i0 < seriesArr.length; i0++) {\n        let avg = (seriesArr[i0][0][1] + seriesArr[i0][1][1])/2\n        let color\n        for (let i1 = 0; i1 < props.glucoseRanges.length; i1++) {\n            if (avg > props.glucoseRanges[i1][0] &&\n                avg < props.glucoseRanges[i1][1]) {\n                color = props.glucoseRanges[i1][2]\n                break\n            }\n        }\n        dataPreSend.push({\n            data: seriesArr[i0],\n            color: hexToRgbA(color, .5)\n        })\n    }\n\n    // Add showable data points for the plotted points\n    // that are actual time and glucose readings\n    // (default functionality is data points do not show,\n    // because many points are only for line color changes;\n    // so actual glucose readings need seperate data series \n    // created for them, and then those series for actual \n    // points need to be added between data series arrays\n    // that are for plotting lines between glucose readings)\n    let dataToSend = []\n    // Loop through array of all series (with range colors)\n    for (let i0 = 0; i0 < dataPreSend.length; i0++) {\n        let firstT = dataPreSend[i0].data[0][0]\n        let firstGl = dataPreSend[i0].data[0][1]\n        let color = dataPreSend[i0].color\n        let dataToPush = []\n        let fAndOrL = \"0\"\n        // Loop through actual glucose readings, and\n        // see if current array in the array of all series\n        // contains 0, 1, or 2 actual glucose readings\n        for (let i1 = 0; i1 < TandGL.length; i1++) {\n            let TandGL0 = TandGL[i1][0]\n            let TandGL1 = TandGL[i1][1]\n            let fillColor = color\n            if (color != undefined) {\n                fillColor = color.slice(0, color.indexOf(\")\") - 3)+\"1)\"\n            }\n            // If the first item in the loop of the previous \n            // array of all series data's first glucose reading\n            // is equal to the current time and glucose reading\n            // in the loop of actual time and glucose readings,\n            // push the data point to the next all series array,\n            // and track that the first item in the loop of the \n            // prev. array of all series data is an actual reading\n            if (firstT == TandGL0 && firstGl == TandGL1) {\n                dataToPush.push({\n                    data: [[firstT, firstGl]],\n                    color: color,\n                    points: {\n                        show: true,\n                        fill: true,\n                        radius: 7,\n                        fillColor: fillColor\n                    }\n                })\n                fAndOrL = \"1\"\n            }\n            // If the second item in the loop of the previous \n            // array of all series data's first glucose reading\n            // is equal to the current time and glucose reading\n            // in the loop of actual time and glucose readings,\n            // push the data point to the next all series array,\n            // and update tracking of which data points of current\n            // item of prev. array of all series data is/are\n            // actual glucose readings\n            let secondT = dataPreSend[i0].data[1][0]\n            let secondGl = dataPreSend[i0].data[1][1]\n            if (secondT == TandGL0 && secondGl == TandGL1) {\n                dataToPush.push({\n                    data: [[secondT, secondGl]],\n                    color: color,\n                    points: {\n                        show: true,\n                        fill: true,\n                        radius: 7,\n                        fillColor: fillColor\n                    }\n                })\n                if (fAndOrL == \"0\") {\n                    fAndOrL = \"2\"\n                } else {\n                    fAndOrL = \"12\"\n                }\n            }\n        }\n        // If neither time and glucose level are\n        // actual glucose readings, push the pair \n        // to the new array of all series data\n        if (fAndOrL == \"0\") {\n            dataToSend.push(dataPreSend[i0])\n        } \n        // If just the first time and glucose level\n        // from the current item from the\n        // previouse array of all series data\n        // is an actual glucose reading, push the\n        // actual glucose reading data point,\n        // the then the current item from the\n        // previous array of all series data\n        else if (fAndOrL == \"1\") {\n            dataToSend.push(dataToPush[0])\n            dataToSend.push(dataPreSend[i0])\n        } \n        // If just the second time and glucose level\n        // from the current item from the previous array \n        // of all series data is an actual glucose reading, \n        // push the current item from the previous array \n        // of all series data, then the current item \n        // from the previous array of all series data\n        else if (fAndOrL == \"2\") {\n            dataToSend.push(dataPreSend[i0])\n            dataToSend.push(dataToPush[0])\n        } \n        // If both time and glucose levels\n        // from the current item from the\n        // previous array of all series data\n        // are actual glucose readings, push the\n        // actual glucose reading data points,\n        // and between them, the current item from \n        // the previous array of all series data\n        else {\n            dataToSend.push(dataToPush[0])\n            dataToSend.push(dataPreSend[i0])\n            dataToSend.push(dataToPush[1])\n        }\n    }\n\n    // This adjusts times for data series, to\n    // eliminate gaps in time between adj. series, \n    // to avoid gaps in lines on the graph\n    for (let i0 = 0; i0 < dataToSend.length - 1; i0++) {\n        let d0 = dataToSend[i0].data\n        let d1 = dataToSend[i0+1].data\n        if (d0.length == 1 && d1.length == 1) {\n            dataToSend.splice(i0, 1)\n        } else {\n            if (d0.length > 1 && d0[1][0] + .01 < d1[0][0]) {\n                for (let i1 = 0; i1 < TandGL.length; i1++) {\n                    if (d0[1][0] === TandGL[i1][0] && d0[1][1] === TandGL[i1][1]) {\n                        d1[0][0] = d0[1][0]\n                    } else if (d1[0][0] === TandGL[i1][0] && d1[0][1] === TandGL[i1][1]) {\n                        d0[1][0] = d1[0][0]\n                    } else {\n                        let num = ((d1[0][0] - d0[1][0]) / 2)\n                        d0[1][0] = d0[1][0] + num\n                        d1[0][0] = d1[0][0] - num\n                    }\n                }\n            }\n        }\n    }\n\n    // Add the plotclick event listener to the graph\n    // that updates the state variable \"modal\", to open\n    // the modal with the appropriate point's data\n    let item0 = item\n    $(`#${item0.date.replaceAll('/', '')}`).off('plotclick')\n        .on('plotclick', function (event, pos, item) {\n        event.stopPropagation()\n        if (item != null && item.datapoint) {\n            for (let i = 0; i < item0.result.length; i++) {\n                let result = item0.result[i]\n                let gL = result.glucose_level\n                let hour = parseInt(result.result_dt_tm.slice(11,13))\n                let min = parseInt(result.result_dt_tm.slice(14,16))\n                let minDec = min/60\n                let time = hour + minDec\n                if (item.datapoint[0] == time && item.datapoint[1] == gL) {\n                    setModal({\n                        open: true,\n                        data: {\n                            glucoseLevelNum: gL,\n                            glucoseLevel: gL + result.glucose_level_unit,\n                            resultDate: result.result_dt_tm,\n                            source: result.source,\n                            resultId: result.result_id\n                        }\n                    })\n                    break\n                }\n            }\n        }\n    });\n\n    return dataToSend\n\n}"]},"metadata":{},"sourceType":"module"}