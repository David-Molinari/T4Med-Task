[{"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/index.js":"1","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/reportWebVitals.js":"2","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/App.js":"3","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/index.js":"4","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Nav/index.js":"5","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/GraphUtils.js":"6","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/jquery-loader.js":"7","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Modal/index.js":"8","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/Utils.js":"9"},{"size":874,"mtime":1624563221162,"results":"10","hashOfConfig":"11"},{"size":362,"mtime":1623178143641,"results":"12","hashOfConfig":"11"},{"size":2537,"mtime":1624568766848,"results":"13","hashOfConfig":"11"},{"size":4802,"mtime":1624310312717,"results":"14","hashOfConfig":"11"},{"size":2139,"mtime":1624310714048,"results":"15","hashOfConfig":"11"},{"size":16021,"mtime":1624310346276,"results":"16","hashOfConfig":"11"},{"size":54,"mtime":1623263624978,"results":"17","hashOfConfig":"11"},{"size":2941,"mtime":1624568595085,"results":"18","hashOfConfig":"11"},{"size":441,"mtime":1624310459963,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"r9bm59",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"27","messages":"28","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"22"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"22"},"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/index.js",[],["42","43"],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/reportWebVitals.js",[],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/App.js",["44"],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/index.js",["45","46","47","48","49"],"import React, { useState, useEffect } from \"react\";\nimport './Graph.css';\nimport '../../jquery-loader';\nimport ReactFlot from 'react-flot';\nimport '../../../node_modules/react-flot/flot/jquery.flot.time.min';\nimport moment from 'moment';\nimport { createData } from './GraphUtils';\nimport ModalComp from '../Modal';\n\nfunction Graph(props) {\n\n    const [modal, setModal] = useState({\n        open: false,\n        data: {\n            glucoseLevel: 0,\n            resultDate: \"\",\n            source: \"\",\n            resultId: \"\"\n        }\n    })\n\n    // On date change, update DOM on delay\n    // to allow plotclick to attach\n    const [ready, setReady] = useState(false)\n    useEffect(()=> {\n        setTimeout(()=> {\n            setReady(false)\n            setReady(true)\n        }, [100])\n    }, [props.selectedDates])\n\n    // Build object of glucose readings by day\n    let glucoseDBD = {}\n    for (let i = 0; i < props.glucoseData.length; i++) {\n        let reading = props.glucoseData[i]\n        let dT = reading.result_dt_tm\n        let day = dT.slice(0,10)\n        if (glucoseDBD[day] == undefined) {\n            glucoseDBD[day] = [reading]\n        } else {\n            glucoseDBD[day].push(reading)\n        }\n    }\n\n    // Build array of glucose readings by day\n    let glucoseDBDArr = []\n    for (let i = 0; i < Object.keys(glucoseDBD).length; i++) {\n        let date = Object.keys(glucoseDBD)[i]\n        glucoseDBDArr.push({\n            date: date,\n            result: glucoseDBD[date]\n        })\n    }\n    glucoseDBDArr.reverse()\n\n    // Format x-axis ticks\n    let ticks = [[0,\"00:00\"]]\n    for (let i = 2; i < 25; i = i + 2) {\n        if (i < 10) {\n            ticks.push([i, `0${i}:00`])\n        } else {\n            ticks.push([i, `${i}:00`]) \n        }\n    }\n    \n    if (window.innerWidth < 725) {\n        ticks = [[0,\"00\"]]\n        for (let i = 2; i < 25; i = i + 2) {\n            if (i < 10) {\n                ticks.push([i, `0${i}`])\n            } else {\n                ticks.push([i, `${i}`]) \n            }\n        }\n    }\n\n    // Define options for flot graphs\n    const options = {\n        xaxis: {\n            min: 0, \n            max: 24, \n            mode: \"time\", \n            timeformat: \"%H:%M\",\n            ticks: ticks\n        }, \n        yaxis: {\n            min: 0, \n            max: 700,\n            ticks: [100, 180]\n        },\n        series: {\n            lines: { \n                show: true, \n                lineWidth: 5 \n            }\n        },\n        grid: {\n            clickable: true,\n            autoHighlight: false\n        }\n    }\n\n    return (\n        <div id=\"Graphs\">\n            {\n            // Map graphs in range of selected dates\n            props.selectedDates.start.length > 0 ?\n                glucoseDBDArr.map((item) => {\n                    let momentS = moment(props.selectedDates.start).format('L')\n                    let momentE = moment(props.selectedDates.end).format('L')\n                    // Add special classes to first and last chart for styling\n                    if (item.date >= momentS && item.date <= momentE) {\n                        let addClass = \"\"\n                        if (momentS == momentE) {\n                            addClass = \"onlyChart\"\n                        } else if (momentS == item.date) {\n                            addClass = \"lastChart\"\n                        }\n                        return (\n                            <div \n                                key={`cc${item.date.replaceAll('/', '')}`}\n                                className={`ChartContainer ${addClass}`}\n                            >\n                                <h5 \n                                    key={`cd${item.date.replaceAll('/', '')}`}\n                                    className=\"ChartDate\"\n                                >\n                                    {item.date}\n                                </h5>\n                                <ReactFlot\n                                    key={`rf${item.date.replaceAll('/', '')}`}\n                                    id={`${item.date.replaceAll('/', '')}`} \n                                    className=\"FlotChart\"\n                                    data={createData(item, props, setModal)} \n                                    options={options} \n                                    width=\"100%\" \n                                    height=\"250px\" \n                                />\n                            </div>\n                        )\n                    }\n                })\n            : \" \"\n            }\n            <ModalComp\n                id=\"Modal\"\n                modal={modal} \n                setModal={setModal}\n                glucoseRanges={props.glucoseRanges}\n            />\n        </div>\n    );\n}\n\nexport default Graph;","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Nav/index.js",[],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/GraphUtils.js",["50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69"],"import $ from \"jquery\";\nimport { hexToRgbA } from '../../Utils';\n\n// Create data series for the day's flot graph\nexport function createData(item, props, setModal) {\n    \n    // Create initial data array of objects, including\n    // ranges accompanied by readings in each range\n    let data = []\n    for (let i = 0; i < props.glucoseRanges.length; i++) {\n        let dataObj = {\n            range: props.glucoseRanges[i].slice(0,2),\n            data: []\n        }\n        data.push(dataObj)\n    }\n\n    for (let i0 = 0; i0 < item.result.length; i0++) {\n        for (let i1 = 0; i1 < data.length; i1++) {\n            let gL = item.result[i0].glucose_level\n            if (gL >= data[i1].range[0] && gL <= data[i1].range[1]) {\n                let hour = parseInt(item.result[i0].result_dt_tm.slice(11,13))\n                let min = parseInt(item.result[i0].result_dt_tm.slice(14,16))\n                let minDec = min/60\n                let time = hour + minDec\n                data[i1].data.push([time, gL])\n            }\n        }\n    }\n\n    // Build array of arrays containing only each \n    // reading's time and glucose level\n    let TandGL = []\n    for (let i = 0; i < data.length; i++) {\n        if (data[i].data.length != undefined) {\n            data[i].data.forEach((arr) => {\n                TandGL.push(arr)\n            })\n        }\n    }\n\n    TandGL.sort((a, b) => {\n        return a[0] - b[0]\n    })\n\n    // Build array holding all ranges' thresholds\n    let thresholds = []\n    for (let i = 0; i < props.glucoseRanges.length; i++) {\n        thresholds.push(props.glucoseRanges[i][0])\n        thresholds.push(props.glucoseRanges[i][1])\n    }\n\n    // Begin creating data series to pass to flot graphs\n    // (the points to plot lines between)\n    let seriesArr = []\n    for (let i0 = 0; i0 < TandGL.length - 1; i0++) {\n        // Functionality for assending glucose levels between readings\n        if (TandGL.length > 0 && TandGL[i0][1] < TandGL[i0+1][1]) {\n            // Except on the inital loop, add to the end of\n            // the series array the last point and the current one\n            // (to create next points to draw line between)\n            if (seriesArr.length > 0) {\n                seriesArr.push([\n                    seriesArr[seriesArr.length-1][1],\n                    TandGL[i0]\n                ])\n            }\n            // Track number of threshold passes between adjecent readings\n            // (to add points at threshold passes, to allow for different\n            // colors of plot lines in between glucose readings)\n            let thresholdPasses = []\n            for (let i1 = 0; i1 < thresholds.length; i1++) {\n                if (TandGL[i0][1] < thresholds[i1] && \n                    TandGL[i0+1][1] > thresholds[i1]) {\n                    thresholdPasses.push(thresholds[i1])\n                }\n            }\n            // Add current time and glucose level \n            // to array that holds next series to pass\n            // to the array holding all series\n            let currentSeries = [TandGL[i0]]\n            // Get points and time gap between series\n            // (to be able to calculate times thresholds\n            // were passed, if glucose levels changed linearly)\n            let totalTimeGap = TandGL[i0+1][0] - TandGL[i0][0]\n            let totalPointsGap = TandGL[i0+1][1] - TandGL[i0][1]\n            // Loop through threshold passes to plot points\n            // for threshold passes between glucose readings\n            // (to allow line colors to match ranges)\n            for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n                let pointsDif = thresholdPasses[i2] - TandGL[i0][1]\n                let percOfTot = pointsDif/totalPointsGap\n                let timeToAdd = percOfTot * totalTimeGap \n                let time = timeToAdd + TandGL[i0][0]\n                // Add to the temp series to be pushed to all series,\n                // the time that each threshold was passed\n                currentSeries.push([time, thresholdPasses[i2]])\n                // If on last threshold pass, push next\n                // time and glucose reading to temp series\n                if (i2 == thresholdPasses.length - 1) {\n                    currentSeries.push(TandGL[i0+1])\n                }\n                // If the temp series has 2 points,\n                // push to the series array and empty\n                if (currentSeries.length == 2) {\n                    seriesArr.push(currentSeries)\n                    currentSeries = []\n                }\n            }\n            // If no threshold passes, push to the series array\n            // the current and next times and glucose readings\n            // (because no points for color changes are needed)\n            if (thresholdPasses.length == 0) {\n                currentSeries.push(TandGL[i0+1])\n                seriesArr.push(currentSeries)\n            }\n        // Functionality for decreasing glucose levels between readings\n        } else if (TandGL.length > 0 && TandGL[i0][1] > TandGL[i0+1][1]) {\n            // Except on the inital loop, add to the end of the array\n            // holding all series - the last point and the current one\n            // (to create next points to draw line between)\n            if (seriesArr.length > 0) {\n                seriesArr.push([\n                    seriesArr[seriesArr.length-1][1],\n                    TandGL[i0]\n                ])\n            }\n            // Track number of threshold passes between adjecent readings\n            // (to add points at threshold passes, to allow for different\n            // colors of plot lines in between glucose readings)\n            let thresholdPasses = []\n            for (let i1 = 0; i1 < thresholds.length; i1++) {\n                if (TandGL[i0+1][1] < thresholds[i1] && \n                    TandGL[i0][1] > thresholds[i1]) {\n                    thresholdPasses.push(thresholds[i1])\n                }\n            }\n            thresholdPasses.reverse()\n            // Add current time and glucose level \n            // to array that holds next series to pass\n            // to the array holding all series\n            let currentSeries = [TandGL[i0]]\n            // Get points and time gap between series\n            // (to be able to calculate times thresholds\n            // were passed, if glucose levels changed linearly)\n            let totalTimeGap = TandGL[i0][0] - TandGL[i0+1][0]\n            let totalPointsGap = TandGL[i0+1][1] - TandGL[i0][1]\n            // Loop through threshold passes to plot points\n            // for threshold passes between glucose readings\n            // (to allow line colors to match ranges)\n            for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n                let pointsDif = TandGL[i0][1] - thresholdPasses[i2]\n                let percOfTot = pointsDif/totalPointsGap\n                let timeToAdd = percOfTot * totalTimeGap \n                let time = timeToAdd + TandGL[i0][0]\n                // Add to the temp series to be pushed to all series,\n                // the time that each threshold was passed\n                currentSeries.push([time, thresholdPasses[i2]])\n                // If on last threshold pass, push next\n                // time and glucose reading to temp series\n                if (i2 == thresholdPasses.length - 1 ) {\n                    currentSeries.push(TandGL[i0+1])\n                }\n                // If the temp series has 2 points,\n                // push to the series array and empty\n                if (currentSeries.length == 2) {\n                    seriesArr.push(currentSeries)\n                    currentSeries = []\n                }\n            }\n            // If no threshold passes, push to the series array\n            // the current and next times and glucose readings\n            // (because no points for color changes are needed)\n            if (thresholdPasses.length == 0) {\n                currentSeries.push(TandGL[i0+1])\n                seriesArr.push(currentSeries)\n            }\n        }\n    }\n\n    // Add appropriate color for each data series,\n    // and push to new array hold all series\n    let dataPreSend = []\n    for (let i0 = 0; i0 < seriesArr.length; i0++) {\n        let avg = (seriesArr[i0][0][1] + seriesArr[i0][1][1])/2\n        let color\n        for (let i1 = 0; i1 < props.glucoseRanges.length; i1++) {\n            if (avg > props.glucoseRanges[i1][0] &&\n                avg < props.glucoseRanges[i1][1]) {\n                color = props.glucoseRanges[i1][2]\n                break\n            }\n        }\n        dataPreSend.push({\n            data: seriesArr[i0],\n            color: hexToRgbA(color, .5)\n        })\n    }\n\n    // Add showable data points for the plotted points\n    // that are actual time and glucose readings\n    // (default functionality is data points do not show,\n    // because many points are only for line color changes;\n    // so actual glucose readings need seperate data series \n    // created for them, and then those series for actual \n    // points need to be added between data series arrays\n    // that are for plotting lines between glucose readings)\n    let dataToSend = []\n    // Loop through array of all series (with range colors)\n    for (let i0 = 0; i0 < dataPreSend.length; i0++) {\n        let firstT = dataPreSend[i0].data[0][0]\n        let firstGl = dataPreSend[i0].data[0][1]\n        let color = dataPreSend[i0].color\n        let dataToPush = []\n        let fAndOrL = \"0\"\n        // Loop through actual glucose readings, and\n        // see if current array in the array of all series\n        // contains 0, 1, or 2 actual glucose readings\n        for (let i1 = 0; i1 < TandGL.length; i1++) {\n            let TandGL0 = TandGL[i1][0]\n            let TandGL1 = TandGL[i1][1]\n            let fillColor = color\n            if (color != undefined) {\n                fillColor = color.slice(0, color.indexOf(\")\") - 3)+\"1)\"\n            }\n            // If the first item in the loop of the previous \n            // array of all series data's first glucose reading\n            // is equal to the current time and glucose reading\n            // in the loop of actual time and glucose readings,\n            // push the data point to the next all series array,\n            // and track that the first item in the loop of the \n            // prev. array of all series data is an actual reading\n            if (firstT == TandGL0 && firstGl == TandGL1) {\n                dataToPush.push({\n                    data: [[firstT, firstGl]],\n                    color: color,\n                    points: {\n                        show: true,\n                        fill: true,\n                        radius: 7,\n                        fillColor: fillColor\n                    }\n                })\n                fAndOrL = \"1\"\n            }\n            // If the second item in the loop of the previous \n            // array of all series data's first glucose reading\n            // is equal to the current time and glucose reading\n            // in the loop of actual time and glucose readings,\n            // push the data point to the next all series array,\n            // and update tracking of which data points of current\n            // item of prev. array of all series data is/are\n            // actual glucose readings\n            let secondT = dataPreSend[i0].data[1][0]\n            let secondGl = dataPreSend[i0].data[1][1]\n            if (secondT == TandGL0 && secondGl == TandGL1) {\n                dataToPush.push({\n                    data: [[secondT, secondGl]],\n                    color: color,\n                    points: {\n                        show: true,\n                        fill: true,\n                        radius: 7,\n                        fillColor: fillColor\n                    }\n                })\n                if (fAndOrL == \"0\") {\n                    fAndOrL = \"2\"\n                } else {\n                    fAndOrL = \"12\"\n                }\n            }\n        }\n        // If neither time and glucose level are\n        // actual glucose readings, push the pair \n        // to the new array of all series data\n        if (fAndOrL == \"0\") {\n            dataToSend.push(dataPreSend[i0])\n        } \n        // If just the first time and glucose level\n        // from the current item from the\n        // previouse array of all series data\n        // is an actual glucose reading, push the\n        // actual glucose reading data point,\n        // the then the current item from the\n        // previous array of all series data\n        else if (fAndOrL == \"1\") {\n            dataToSend.push(dataToPush[0])\n            dataToSend.push(dataPreSend[i0])\n        } \n        // If just the second time and glucose level\n        // from the current item from the previous array \n        // of all series data is an actual glucose reading, \n        // push the current item from the previous array \n        // of all series data, then the current item \n        // from the previous array of all series data\n        else if (fAndOrL == \"2\") {\n            dataToSend.push(dataPreSend[i0])\n            dataToSend.push(dataToPush[0])\n        } \n        // If both time and glucose levels\n        // from the current item from the\n        // previous array of all series data\n        // are actual glucose readings, push the\n        // actual glucose reading data points,\n        // and between them, the current item from \n        // the previous array of all series data\n        else {\n            dataToSend.push(dataToPush[0])\n            dataToSend.push(dataPreSend[i0])\n            dataToSend.push(dataToPush[1])\n        }\n    }\n\n    // This adjusts times for data series, to\n    // eliminate gaps in time between adj. series, \n    // to avoid gaps in lines on the graph\n    for (let i0 = 0; i0 < dataToSend.length - 1; i0++) {\n        let d0 = dataToSend[i0].data\n        let d1 = dataToSend[i0+1].data\n        if (d0.length == 1 && d1.length == 1) {\n            dataToSend.splice(i0, 1)\n        } else {\n            if (d0.length > 1 && d0[1][0] + .01 < d1[0][0]) {\n                for (let i1 = 0; i1 < TandGL.length; i1++) {\n                    if (d0[1][0] === TandGL[i1][0] && d0[1][1] === TandGL[i1][1]) {\n                        d1[0][0] = d0[1][0]\n                    } else if (d1[0][0] === TandGL[i1][0] && d1[0][1] === TandGL[i1][1]) {\n                        d0[1][0] = d1[0][0]\n                    } else {\n                        let num = ((d1[0][0] - d0[1][0]) / 2)\n                        d0[1][0] = d0[1][0] + num\n                        d1[0][0] = d1[0][0] - num\n                    }\n                }\n            }\n        }\n    }\n\n    // Add the plotclick event listener to the graph\n    // that updates the state variable \"modal\", to open\n    // the modal with the appropriate point's data\n    let item0 = item\n    $(`#${item0.date.replaceAll('/', '')}`).off('plotclick')\n        .on('plotclick', function (event, pos, item) {\n        event.stopPropagation()\n        if (item != null && item.datapoint) {\n            for (let i = 0; i < item0.result.length; i++) {\n                let result = item0.result[i]\n                let gL = result.glucose_level\n                let hour = parseInt(result.result_dt_tm.slice(11,13))\n                let min = parseInt(result.result_dt_tm.slice(14,16))\n                let minDec = min/60\n                let time = hour + minDec\n                if (item.datapoint[0] == time && item.datapoint[1] == gL) {\n                    setModal({\n                        open: true,\n                        data: {\n                            glucoseLevelNum: gL,\n                            glucoseLevel: gL + result.glucose_level_unit,\n                            resultDate: result.result_dt_tm,\n                            source: result.source,\n                            resultId: result.result_id\n                        }\n                    })\n                    break\n                }\n            }\n        }\n    });\n\n    return dataToSend\n\n}","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/jquery-loader.js",[],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Modal/index.js",["70","71"],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/Utils.js",["72","73"],"export function hexToRgbA(hex, dec){\n    if (hex != undefined) {\n        var c;\n        if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){\n            c= hex.substring(1).split('');\n            if(c.length== 3){\n                c= [c[0], c[0], c[1], c[1], c[2], c[2]];\n            }\n            c= '0x'+c.join('');\n            return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+`,${dec})`;\n        }\n        throw new Error('Bad Hex');\n    }\n}",{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","severity":1,"message":"79","line":64,"column":6,"nodeType":"80","endLine":64,"endColumn":12,"suggestions":"81"},{"ruleId":"82","severity":1,"message":"83","line":24,"column":12,"nodeType":"84","messageId":"85","endLine":24,"endColumn":17},{"ruleId":"86","severity":1,"message":"87","line":38,"column":29,"nodeType":"88","messageId":"89","endLine":38,"endColumn":31},{"ruleId":"90","severity":1,"message":"91","line":108,"column":42,"nodeType":"92","messageId":"93","endLine":108,"endColumn":44},{"ruleId":"86","severity":1,"message":"87","line":114,"column":37,"nodeType":"88","messageId":"89","endLine":114,"endColumn":39},{"ruleId":"86","severity":1,"message":"87","line":116,"column":44,"nodeType":"88","messageId":"89","endLine":116,"endColumn":46},{"ruleId":"86","severity":1,"message":"94","line":35,"column":33,"nodeType":"88","messageId":"89","endLine":35,"endColumn":35},{"ruleId":"86","severity":1,"message":"87","line":100,"column":24,"nodeType":"88","messageId":"89","endLine":100,"endColumn":26},{"ruleId":"86","severity":1,"message":"87","line":105,"column":42,"nodeType":"88","messageId":"89","endLine":105,"endColumn":44},{"ruleId":"86","severity":1,"message":"87","line":113,"column":40,"nodeType":"88","messageId":"89","endLine":113,"endColumn":42},{"ruleId":"86","severity":1,"message":"87","line":161,"column":24,"nodeType":"88","messageId":"89","endLine":161,"endColumn":26},{"ruleId":"86","severity":1,"message":"87","line":166,"column":42,"nodeType":"88","messageId":"89","endLine":166,"endColumn":44},{"ruleId":"86","severity":1,"message":"87","line":174,"column":40,"nodeType":"88","messageId":"89","endLine":174,"endColumn":42},{"ruleId":"86","severity":1,"message":"94","line":223,"column":23,"nodeType":"88","messageId":"89","endLine":223,"endColumn":25},{"ruleId":"86","severity":1,"message":"87","line":233,"column":24,"nodeType":"88","messageId":"89","endLine":233,"endColumn":26},{"ruleId":"86","severity":1,"message":"87","line":233,"column":46,"nodeType":"88","messageId":"89","endLine":233,"endColumn":48},{"ruleId":"86","severity":1,"message":"87","line":256,"column":25,"nodeType":"88","messageId":"89","endLine":256,"endColumn":27},{"ruleId":"86","severity":1,"message":"87","line":256,"column":48,"nodeType":"88","messageId":"89","endLine":256,"endColumn":50},{"ruleId":"86","severity":1,"message":"87","line":267,"column":29,"nodeType":"88","messageId":"89","endLine":267,"endColumn":31},{"ruleId":"86","severity":1,"message":"87","line":277,"column":21,"nodeType":"88","messageId":"89","endLine":277,"endColumn":23},{"ruleId":"86","severity":1,"message":"87","line":287,"column":26,"nodeType":"88","messageId":"89","endLine":287,"endColumn":28},{"ruleId":"86","severity":1,"message":"87","line":297,"column":26,"nodeType":"88","messageId":"89","endLine":297,"endColumn":28},{"ruleId":"86","severity":1,"message":"87","line":321,"column":23,"nodeType":"88","messageId":"89","endLine":321,"endColumn":25},{"ruleId":"86","severity":1,"message":"87","line":321,"column":41,"nodeType":"88","messageId":"89","endLine":321,"endColumn":43},{"ruleId":"86","severity":1,"message":"87","line":355,"column":39,"nodeType":"88","messageId":"89","endLine":355,"endColumn":41},{"ruleId":"86","severity":1,"message":"87","line":355,"column":68,"nodeType":"88","messageId":"89","endLine":355,"endColumn":70},{"ruleId":"86","severity":1,"message":"87","line":16,"column":30,"nodeType":"88","messageId":"89","endLine":16,"endColumn":32},{"ruleId":"78","severity":1,"message":"95","line":25,"column":8,"nodeType":"80","endLine":25,"endColumn":21,"suggestions":"96"},{"ruleId":"86","severity":1,"message":"94","line":2,"column":13,"nodeType":"88","messageId":"89","endLine":2,"endColumn":15},{"ruleId":"86","severity":1,"message":"87","line":6,"column":24,"nodeType":"88","messageId":"89","endLine":6,"endColumn":26},"no-native-reassign",["97"],"no-negated-in-lhs",["98"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'loading'. Either include it or remove the dependency array.","ArrayExpression",["99"],"no-unused-vars","'ready' is assigned a value but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","Expected '!==' and instead saw '!='.","React Hook useEffect has a missing dependency: 'props.glucoseRanges'. Either include it or remove the dependency array.",["100"],"no-global-assign","no-unsafe-negation",{"desc":"101","fix":"102"},{"desc":"103","fix":"104"},"Update the dependencies array to be: [data, loading]",{"range":"105","text":"106"},"Update the dependencies array to be: [props.glucoseRanges, props.modal]",{"range":"107","text":"108"},[1618,1624],"[data, loading]",[833,846],"[props.glucoseRanges, props.modal]"]