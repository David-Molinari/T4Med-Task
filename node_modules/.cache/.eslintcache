[{"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/reportWebVitals.js":"1","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/jquery-loader.js":"2","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/index.tsx":"3","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/App.tsx":"4","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Nav/index.tsx":"5","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/index.tsx":"6","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/GraphUtils.tsx":"7","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/Utils.tsx":"8","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Modal/index.tsx":"9"},{"size":362,"mtime":1623178143641,"results":"10","hashOfConfig":"11"},{"size":54,"mtime":1623263624978,"results":"12","hashOfConfig":"11"},{"size":865,"mtime":1624657172081,"results":"13","hashOfConfig":"11"},{"size":3406,"mtime":1624654407857,"results":"14","hashOfConfig":"11"},{"size":2631,"mtime":1624646210219,"results":"15","hashOfConfig":"11"},{"size":6122,"mtime":1624657163056,"results":"16","hashOfConfig":"11"},{"size":12419,"mtime":1624655639444,"results":"17","hashOfConfig":"11"},{"size":438,"mtime":1624655001414,"results":"18","hashOfConfig":"11"},{"size":3403,"mtime":1624656237391,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"3z3gmg",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"35","messages":"36","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"30"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"30"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"30"},"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/reportWebVitals.js",[],["44","45"],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/jquery-loader.js",[],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/index.tsx",[],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/App.tsx",["46"],"import { useEffect, useState } from \"react\";\nimport './App.css';\nimport moment from \"moment\";\nimport Nav from \"./components/Nav\";\nimport Graph from \"./components/Graph\";\nimport {\n  useQuery,\n  gql\n} from \"@apollo/client\";\nimport { Modal, ModalHeader, ModalBody } from 'reactstrap';\n\nconst GET_RANGES_AND_DATA = gql`\n  query GetRangesAndData {\n    ranges {\n      low_bound\n      high_bound\n      color\n    }\n    data {\n      result_id\n      result_dt_tm\n      glucose_level\n      glucose_level_unit\n      source\n    }\n  }\n`;\n\ninterface IRange {\n  _id?: string,\n  low_bound: number,\n  high_bound: number,\n  color: string\n}\n\ntype RangeTuple = [number, number, string]\n\ninterface IData {\n  _id: string,\n  result_id: string,\n  result_dt_tm: string,\n  glucose_level: number,\n  glucose_level_unit: string,\n  source: string\n}\n\ntype Data = {\n  ranges: IRange[],\n  data: IData[]\n}\n\nfunction App(): JSX.Element {\n\n  const [glucoseData, setGlucoseData] = useState<IData[]>([])\n  const [glucoseRangeTuples, setGlucoseRangeTuples] = useState<RangeTuple[]>([])\n  const [selectedDates, setSelectedDates] = useState({\n    start: \"\",\n    end: \"\"\n  })\n  const [modalOpen, setModalOpen] = useState<boolean>(true)\n\n  const toggle = (): void => setModalOpen(false);\n\n  const { loading, error, data } = useQuery<Data>(GET_RANGES_AND_DATA);\n\n  // On load of data, set initial state\n\n  useEffect(()=> {\n    if (!loading && data !== undefined) {\n      let dataClone: IData[] = []\n      data.data.forEach((e: IData): void => {\n        dataClone.push(e)\n      })\n      dataClone.sort((a: IData, b: IData): number => {\n        return (\n          new Date(a.result_dt_tm.slice(0,10)).getTime() - \n          new Date(b.result_dt_tm.slice(0,10)).getTime()\n        )\n      })\n      setGlucoseData(dataClone)\n      let rangesToArrays: RangeTuple[] = []\n      data.ranges.forEach((r: IRange): void => {\n        rangesToArrays.push([r.low_bound, r.high_bound, r.color])\n      })\n      rangesToArrays.sort(function(a: RangeTuple, b: RangeTuple): number {\n        return a[0] - b[0];\n      });\n      setGlucoseRangeTuples(rangesToArrays)\n      let startDT: string = dataClone[0].result_dt_tm\n      let startD:string = moment(startDT.slice(0, startDT.search(\" \"))).format()\n      let endDT:string = dataClone[dataClone.length - 1].result_dt_tm\n      let endD:string = moment(endDT.slice(0, endDT.search(\" \"))).format()\n      setSelectedDates({\n        start: startD,\n        end: endD\n      })\n    }\n  }, [data])\n\n  if (error) {\n    console.log(error)\n  };\n\n  return (\n    <>\n      {!loading && glucoseData.length ? \n        <div className=\"App\">\n            <Modal isOpen={modalOpen} className=\"Modal\">\n              <ModalHeader \n                    className=\"ModalHeader\" \n                    toggle={toggle}\n              >\n                See more info\n              </ModalHeader>\n              <ModalBody \n                  className=\"ModalBody\"\n              >\n                Click data point (colored dot) for more info on that reading\n              </ModalBody>\n          </Modal>\n          <Nav selectedDates={selectedDates} setSelectedDates={setSelectedDates} glucoseData={glucoseData}/>\n          <Graph selectedDates={selectedDates} glucoseData={glucoseData} glucoseRangeTuples={glucoseRangeTuples}/>\n        </div>\n      : \n        <h1 id=\"Loading\">\n          Loading...\n        </h1>\n      }\n    </>\n  );\n}\n\nexport default App;",["47","48"],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Nav/index.tsx",[],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/index.tsx",["49","50","51","52"],"/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Graph/GraphUtils.tsx",["53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72"],"import { Dispatch } from \"react\";\nimport $ from \"jquery\";\nimport { hexToRgbA } from '../../Utils';\n\ninterface IData {\n    _id: string,\n    result_id: string,\n    result_dt_tm: string,\n    glucose_level: number,\n    glucose_level_unit: string,\n    source: string\n}\n\ninterface IItem {\n    date: string, \n    result: IData[]\n}\n\ninterface ISelectedDates {\n    start: string,\n    end: string\n}\n\n// interface IRange {\n//     _id?: string,\n//     low_bound: number,\n//     high_bound: number,\n//     color: string\n// }\n\ntype RangeTuple = [number, number, string]\n\ninterface IProps {\n    selectedDates: ISelectedDates,\n    glucoseData: IData[],\n    glucoseRangeTuples: RangeTuple[]\n}\n\ninterface IModal {\n    open: boolean;\n    data: {\n        glucoseLevelNum?: number,\n        glucoseLevel: number | string,\n        resultDate: string,\n        source: string,\n        resultId: string\n    };\n}\n\ntype TTandGL = [number, number]\n\ninterface IRandD {\n    range: [number, number],\n    data: TTandGL[]\n}\n\ntype TSeries = [[number, number], [number, number]]\n\ninterface IDataPreSend {\n    data: TSeries,\n    color: string\n}\n\ntype TDataPoint = number[][]\n\ninterface IDataToPush {\n    data: TDataPoint,\n    color: string,\n    points?: {\n        show: boolean;\n        fill: boolean;\n        radius: number;\n        fillColor: string;\n    }\n}\n\n// Create data series for the day's flot graph\nexport function createData(item: IItem, props: IProps, setModal: Dispatch<IModal>) {\n    \n    // Create initial data array of objects, including\n    // ranges accompanied by readings in each range\n    let rAndD: IRandD[] = []\n    for (let i = 0; i < props.glucoseRangeTuples.length; i++) {\n        let dataObj: IRandD = {\n            range: [props.glucoseRangeTuples[i][0],props.glucoseRangeTuples[i][1]],\n            data: []\n        }\n        rAndD.push(dataObj)\n    }\n\n    for (let i0 = 0; i0 < item.result.length; i0++) {\n        for (let i1 = 0; i1 < rAndD.length; i1++) {\n            let gL: number = item.result[i0].glucose_level\n            if (gL >= rAndD[i1].range[0] && gL <= rAndD[i1].range[1]) {\n                let hour: number = parseInt(item.result[i0].result_dt_tm.slice(11,13))\n                let min: number = parseInt(item.result[i0].result_dt_tm.slice(14,16))\n                let minDec: number = min/60\n                let time: number = hour + minDec\n                rAndD[i1].data.push([time, gL])\n            }\n        }\n    }\n\n    // Build array of arrays containing only each \n    // reading's time and glucose level\n    let TandGL: TTandGL[] = []\n    for (let i = 0; i < rAndD.length; i++) {\n        if (rAndD[i].data.length != undefined) {\n            rAndD[i].data.forEach((arr) => {\n                TandGL.push(arr)\n            })\n        }\n    }\n\n    TandGL.sort((a: TTandGL, b: TTandGL): number => {\n        return a[0] - b[0]\n    })\n\n    // Build array holding all ranges' thresholds\n    let thresholds: number[] = []\n    for (let i = 0; i < props.glucoseRangeTuples.length; i++) {\n        thresholds.push(props.glucoseRangeTuples[i][0])\n        thresholds.push(props.glucoseRangeTuples[i][1])\n    }\n\n    // Begin creating data series to pass to flot graphs\n    // (the points to plot lines between)\n    let seriesArr: TSeries[] = []\n    for (let i0 = 0; i0 < TandGL.length - 1; i0++) {\n        // Functionality for assending glucose levels between readings\n        if (TandGL.length > 0 && TandGL[i0][1] < TandGL[i0+1][1]) {\n            if (seriesArr.length > 0) {\n                seriesArr.push([\n                    seriesArr[seriesArr.length-1][1],\n                    TandGL[i0]\n                ])\n            }\n            let thresholdPasses: number[] = []\n            for (let i1 = 0; i1 < thresholds.length; i1++) {\n                if (TandGL[i0][1] < thresholds[i1] && \n                    TandGL[i0+1][1] > thresholds[i1]) {\n                    thresholdPasses.push(thresholds[i1])\n                }\n            }\n            let currentTSeries: TTandGL[] = [TandGL[i0]]\n            let totalTimeGap: number = TandGL[i0+1][0] - TandGL[i0][0]\n            let totalPointsGap: number = TandGL[i0+1][1] - TandGL[i0][1]\n            for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n                let pointsDif: number = thresholdPasses[i2] - TandGL[i0][1]\n                let percOfTot: number = pointsDif/totalPointsGap\n                let timeToAdd: number = percOfTot * totalTimeGap \n                let time: number = timeToAdd + TandGL[i0][0]\n                currentTSeries.push([time, thresholdPasses[i2]])\n                if (i2 == thresholdPasses.length - 1) {\n                    currentTSeries.push(TandGL[i0+1])\n                }\n                if (currentTSeries.length == 2) {\n                    seriesArr.push([currentTSeries[0], currentTSeries[1]])\n                    currentTSeries = []\n                }\n            }\n            if (thresholdPasses.length == 0) {\n                currentTSeries.push(TandGL[i0+1])\n                seriesArr.push([currentTSeries[0], currentTSeries[1]])\n            }\n        // Functionality for decreasing glucose levels between readings\n        } else if (TandGL.length > 0 && TandGL[i0][1] > TandGL[i0+1][1]) {\n            if (seriesArr.length > 0) {\n                seriesArr.push([\n                    seriesArr[seriesArr.length-1][1],\n                    TandGL[i0]\n                ])\n            }\n            let thresholdPasses: number[] = []\n            for (let i1 = 0; i1 < thresholds.length; i1++) {\n                if (TandGL[i0+1][1] < thresholds[i1] && \n                    TandGL[i0][1] > thresholds[i1]) {\n                    thresholdPasses.push(thresholds[i1])\n                }\n            }\n            thresholdPasses.reverse()\n            let currentTSeries: TTandGL[] = [TandGL[i0]]\n            let totalTimeGap: number = TandGL[i0][0] - TandGL[i0+1][0]\n            let totalPointsGap: number = TandGL[i0+1][1] - TandGL[i0][1]\n            for (let i2 = 0; i2 < thresholdPasses.length; i2++) {\n                let pointsDif: number = TandGL[i0][1] - thresholdPasses[i2]\n                let percOfTot: number = pointsDif/totalPointsGap\n                let timeToAdd: number = percOfTot * totalTimeGap \n                let time: number = timeToAdd + TandGL[i0][0]\n                currentTSeries.push([time, thresholdPasses[i2]])\n                if (i2 == thresholdPasses.length - 1 ) {\n                    currentTSeries.push(TandGL[i0+1])\n                }\n                if (currentTSeries.length == 2) {\n                    seriesArr.push([currentTSeries[0], currentTSeries[1]])\n                    currentTSeries = []\n                }\n            }\n            if (thresholdPasses.length == 0) {\n                currentTSeries.push(TandGL[i0+1])\n                seriesArr.push([currentTSeries[0], currentTSeries[1]])\n            }\n        }\n    }\n\n    // Add appropriate color for each data series,\n    // and push to new array hold all series\n    let dataPreSend: IDataPreSend[] = []\n    for (let i0 = 0; i0 < seriesArr.length; i0++) {\n        let avg: number = (seriesArr[i0][0][1] + seriesArr[i0][1][1])/2\n        let color: string = \"#fff\"\n        for (let i1 = 0; i1 < props.glucoseRangeTuples.length; i1++) {\n            if (avg > props.glucoseRangeTuples[i1][0] &&\n                avg < props.glucoseRangeTuples[i1][1]) {\n                color = props.glucoseRangeTuples[i1][2]\n                break\n            }\n        }\n        dataPreSend.push({\n            data: seriesArr[i0],\n            color: hexToRgbA(color, .5)\n        })\n    }\n\n    // Add showable data points for the plotted points\n    // that are actual time and glucose readings\n    let dataToSend: IDataToPush[] = []\n    for (let i0 = 0; i0 < dataPreSend.length; i0++) {\n        let firstT: number = dataPreSend[i0].data[0][0]\n        let firstGl: number = dataPreSend[i0].data[0][1]\n        let color: string = dataPreSend[i0].color\n        let dataToPush: IDataToPush[] = []\n        let fAndOrL: string = \"0\"\n        for (let i1 = 0; i1 < TandGL.length; i1++) {\n            let TandGL0: number = TandGL[i1][0]\n            let TandGL1: number = TandGL[i1][1]\n            let fillColor: string = color\n            if (color != undefined) {\n                fillColor = color.slice(0, color.indexOf(\")\") - 3)+\"1)\"\n            }\n            if (firstT == TandGL0 && firstGl == TandGL1) {\n                dataToPush.push({\n                    data: [[firstT, firstGl]],\n                    color: color,\n                    points: {\n                        show: true,\n                        fill: true,\n                        radius: 7,\n                        fillColor: fillColor\n                    }\n                })\n                fAndOrL = \"1\"\n            }\n            let secondT: number = dataPreSend[i0].data[1][0]\n            let secondGl: number = dataPreSend[i0].data[1][1]\n            if (secondT == TandGL0 && secondGl == TandGL1) {\n                dataToPush.push({\n                    data: [[secondT, secondGl]],\n                    color: color,\n                    points: {\n                        show: true,\n                        fill: true,\n                        radius: 7,\n                        fillColor: fillColor\n                    }\n                })\n                if (fAndOrL == \"0\") {\n                    fAndOrL = \"2\"\n                } else {\n                    fAndOrL = \"12\"\n                }\n            }\n        }\n        if (fAndOrL == \"0\") {\n            dataToSend.push(dataPreSend[i0])\n        } \n        else if (fAndOrL == \"1\") {\n            dataToSend.push(dataToPush[0])\n            dataToSend.push(dataPreSend[i0])\n        } \n        else if (fAndOrL == \"2\") {\n            dataToSend.push(dataPreSend[i0])\n            dataToSend.push(dataToPush[0])\n        } \n        else {\n            dataToSend.push(dataToPush[0])\n            dataToSend.push(dataPreSend[i0])\n            dataToSend.push(dataToPush[1])\n        }\n    }\n\n    // This adjusts times for data series, to\n    // eliminate gaps in time between adj. series, \n    // to avoid gaps in lines on the graph\n    for (let i0 = 0; i0 < dataToSend.length - 1; i0++) {\n        let d0: TDataPoint = dataToSend[i0].data\n        let d1: TDataPoint = dataToSend[i0+1].data\n        if (d0.length == 1 && d1.length == 1) {\n            dataToSend.splice(i0, 1)\n        } else {\n            if (d0.length > 1 && d0[1][0] + .01 < d1[0][0]) {\n                for (let i1 = 0; i1 < TandGL.length; i1++) {\n                    if (d0[1][0] === TandGL[i1][0] && d0[1][1] === TandGL[i1][1]) {\n                        d1[0][0] = d0[1][0]\n                    } else if (d1[0][0] === TandGL[i1][0] && d1[0][1] === TandGL[i1][1]) {\n                        d0[1][0] = d1[0][0]\n                    } else {\n                        let num: number = ((d1[0][0] - d0[1][0]) / 2)\n                        d0[1][0] = d0[1][0] + num\n                        d1[0][0] = d1[0][0] - num\n                    }\n                }\n            }\n        }\n    }\n\n    // Add the plotclick event listener to the graph\n    // that updates the state variable \"modal\", to open\n    // the modal with the appropriate point's data\n    let item0: IItem = item\n    $(`#${item0.date.split('/').join('')}`).off('plotclick')\n        .on('plotclick', function (event, item) {\n        event.stopPropagation()\n        if (item != null && item.datapoint) {\n            for (let i = 0; i < item0.result.length; i++) {\n                let result: IData = item0.result[i]\n                let gL: number = result.glucose_level\n                let hour: number = parseInt(result.result_dt_tm.slice(11,13))\n                let min: number = parseInt(result.result_dt_tm.slice(14,16))\n                let minDec: number = min/60\n                let time: number = hour + minDec\n                if (item.datapoint[0] == time && item.datapoint[1] == gL) {\n                    setModal({\n                        open: true,\n                        data: {\n                            glucoseLevelNum: gL,\n                            glucoseLevel: gL + result.glucose_level_unit,\n                            resultDate: result.result_dt_tm,\n                            source: result.source,\n                            resultId: result.result_id\n                        }\n                    })\n                    break\n                }\n            }\n        }\n    });\n\n    return dataToSend\n\n}","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/Utils.tsx",["73"],"export function hexToRgbA(hex: string, dec: number){\n        let c: any;\n        if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){\n            c = hex.substring(1).split('');\n            if(c.length == 3){\n                c = [c[0], c[0], c[1], c[1], c[2], c[2]];\n            }\n            c = '0x' + c.join('');\n            return 'rgba(' + [(c>>16)&255, (c>>8)&255, c&255].join(',') + `,${dec})`;\n        }\n        throw new Error('Bad Hex');\n}","/Users/Dmolina5/Desktop/glucose-reader-app/glucose-reader-fe/src/components/Modal/index.tsx",["74","75"],"import { useState, useEffect, Dispatch } from \"react\";\nimport './Modal.css';\nimport { Modal, ModalHeader, ModalBody } from 'reactstrap';\nimport { hexToRgbA } from '../../Utils';\n\ninterface IModal {\n    open: boolean;\n    data: {\n        glucoseLevelNum?: number,\n        glucoseLevel: number | string,\n        resultDate: string,\n        source: string,\n        resultId: string\n    };\n}\n\ntype RangeTuple = [number, number, string]\n\ninterface IProps {\n    modal: IModal,\n    setModal: Dispatch<IModal>,\n    glucoseRangeTuples: RangeTuple[]\n}\n\nfunction ModalComp(props: IProps) {\n\n    const toggle = (): void => props.setModal({...props.modal, open: false});\n\n    const [color, setColor] = useState<string>(\"\")\n\n    // When the modal state variable is updated,\n    // if open is set to true, add the appropriate\n    // background color to the modal\n    useEffect((): void => {\n        if (props.modal.open == true) {\n            let gl0pass: any = props.modal.data.glucoseLevelNum\n            let gRs: RangeTuple[] = props.glucoseRangeTuples\n            let gL0: number = gl0pass\n            for (let i = 0; i < gRs.length; i++) {\n                if (gL0 >= gRs[i][0] && gL0 <= gRs[i][1]) {\n                    setColor(hexToRgbA(gRs[i][2], .15))\n                }\n            }\n        }\n    }, [props.modal])\n\n    return (\n        <Modal isOpen={props.modal.open} className=\"Modal\">\n            <ModalHeader \n                className=\"ModalHeader\" \n                toggle={toggle}\n                style={{color: color}}\n            >\n                Glucose Reading\n            </ModalHeader>\n            <ModalBody \n                className=\"ModalBody\"\n                style={{backgroundColor: color}}\n            >\n                <div className=\"ModalBodyInnerCont\">\n                    <div \n                        id=\"ModalBodyTopRow\"\n                        className=\"ModalRow\"\n                    >\n                        <h3 className=\"ModalLabel\">\n                            Glucose Level:\n                        </h3>\n                        <h5 className=\"ModalEntry\">\n                            {props.modal.data.glucoseLevel}\n                        </h5>\n                    </div>\n                    <div className=\"ModalRow\">\n                        <h3 className=\"ModalLabel\">\n                            Result Date:\n                        </h3>\n                        <h5 className=\"ModalEntry\">\n                            {props.modal.data.resultDate}\n                        </h5>\n                    </div>\n                    <div className=\"ModalRow\">\n                        <h3 className=\"ModalLabel\">\n                            Source:\n                        </h3>\n                        <h5 className=\"ModalEntry\">\n                            {props.modal.data.source}\n                        </h5>\n                    </div>\n                    <div className=\"ModalRow\">\n                        <h3 className=\"ModalLabel\">\n                            Result ID:\n                        </h3>\n                        <h5 \n                            id=\"ResultIdEntry\"\n                            className=\"ModalEntry\"\n                        >\n                            {props.modal.data.resultId}\n                        </h5>\n                    </div>\n                </div>\n            </ModalBody>\n        </Modal>\n    )\n}\n\nexport default ModalComp;",{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","replacedBy":"79"},{"ruleId":"80","severity":1,"message":"81","line":98,"column":6,"nodeType":"82","endLine":98,"endColumn":12,"suggestions":"83"},{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","replacedBy":"79"},{"ruleId":"84","severity":1,"message":"85","line":102,"column":29,"nodeType":"86","messageId":"87","endLine":102,"endColumn":31},{"ruleId":"88","severity":1,"message":"89","line":172,"column":69,"nodeType":"90","messageId":"91","endLine":172,"endColumn":71},{"ruleId":"84","severity":1,"message":"85","line":178,"column":37,"nodeType":"86","messageId":"87","endLine":178,"endColumn":39},{"ruleId":"84","severity":1,"message":"85","line":180,"column":44,"nodeType":"86","messageId":"87","endLine":180,"endColumn":46},{"ruleId":"84","severity":1,"message":"92","line":108,"column":34,"nodeType":"86","messageId":"87","endLine":108,"endColumn":36},{"ruleId":"84","severity":1,"message":"85","line":154,"column":24,"nodeType":"86","messageId":"87","endLine":154,"endColumn":26},{"ruleId":"84","severity":1,"message":"85","line":157,"column":43,"nodeType":"86","messageId":"87","endLine":157,"endColumn":45},{"ruleId":"84","severity":1,"message":"85","line":162,"column":40,"nodeType":"86","messageId":"87","endLine":162,"endColumn":42},{"ruleId":"84","severity":1,"message":"85","line":191,"column":24,"nodeType":"86","messageId":"87","endLine":191,"endColumn":26},{"ruleId":"84","severity":1,"message":"85","line":194,"column":43,"nodeType":"86","messageId":"87","endLine":194,"endColumn":45},{"ruleId":"84","severity":1,"message":"85","line":199,"column":40,"nodeType":"86","messageId":"87","endLine":199,"endColumn":42},{"ruleId":"84","severity":1,"message":"92","line":238,"column":23,"nodeType":"86","messageId":"87","endLine":238,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":241,"column":24,"nodeType":"86","messageId":"87","endLine":241,"endColumn":26},{"ruleId":"84","severity":1,"message":"85","line":241,"column":46,"nodeType":"86","messageId":"87","endLine":241,"endColumn":48},{"ruleId":"84","severity":1,"message":"85","line":256,"column":25,"nodeType":"86","messageId":"87","endLine":256,"endColumn":27},{"ruleId":"84","severity":1,"message":"85","line":256,"column":48,"nodeType":"86","messageId":"87","endLine":256,"endColumn":50},{"ruleId":"84","severity":1,"message":"85","line":267,"column":29,"nodeType":"86","messageId":"87","endLine":267,"endColumn":31},{"ruleId":"84","severity":1,"message":"85","line":274,"column":21,"nodeType":"86","messageId":"87","endLine":274,"endColumn":23},{"ruleId":"84","severity":1,"message":"85","line":277,"column":26,"nodeType":"86","messageId":"87","endLine":277,"endColumn":28},{"ruleId":"84","severity":1,"message":"85","line":281,"column":26,"nodeType":"86","messageId":"87","endLine":281,"endColumn":28},{"ruleId":"84","severity":1,"message":"85","line":298,"column":23,"nodeType":"86","messageId":"87","endLine":298,"endColumn":25},{"ruleId":"84","severity":1,"message":"85","line":298,"column":41,"nodeType":"86","messageId":"87","endLine":298,"endColumn":43},{"ruleId":"84","severity":1,"message":"85","line":332,"column":39,"nodeType":"86","messageId":"87","endLine":332,"endColumn":41},{"ruleId":"84","severity":1,"message":"85","line":332,"column":68,"nodeType":"86","messageId":"87","endLine":332,"endColumn":70},{"ruleId":"84","severity":1,"message":"85","line":5,"column":25,"nodeType":"86","messageId":"87","endLine":5,"endColumn":27},{"ruleId":"84","severity":1,"message":"85","line":35,"column":30,"nodeType":"86","messageId":"87","endLine":35,"endColumn":32},{"ruleId":"80","severity":1,"message":"93","line":45,"column":8,"nodeType":"82","endLine":45,"endColumn":21,"suggestions":"94"},"no-native-reassign",["95"],"no-negated-in-lhs",["96"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'loading'. Either include it or remove the dependency array.","ArrayExpression",["97"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","Expected '!==' and instead saw '!='.","React Hook useEffect has a missing dependency: 'props.glucoseRangeTuples'. Either include it or remove the dependency array.",["98"],"no-global-assign","no-unsafe-negation",{"desc":"99","fix":"100"},{"desc":"101","fix":"102"},"Update the dependencies array to be: [data, loading]",{"range":"103","text":"104"},"Update the dependencies array to be: [props.glucoseRangeTuples, props.modal]",{"range":"105","text":"106"},[2466,2472],"[data, loading]",[1295,1308],"[props.glucoseRangeTuples, props.modal]"]